using System;using System.IO;using System.Windows.Forms;using System.Text;using System.Data;namespace EarLab.ReaderWriters{	/// <summary>	/// This class can be used to read EarLab multi-dimensional data from file.	/// </summary>	public class ReaderWriterBinary	{		private	const int FLOAT_BYTES = 4;		private string fileName;		private BinaryReader outputFileReader;		public struct Dimension		{			public string Name;			public long Size;			public int Index;			public double Start, End;			public double[] ElementArray;		}		private Dimension[] dimensionsArray;		private double minimumValue, maximumValue;		private string unitsString = "Magnitude";		#region Construtor/Destructor		public ReaderWriterBinary(){}		public void Close()		{			if (this.outputFileReader != null)			{				this.outputFileReader.Close();				this.outputFileReader = null;			}		}		~ReaderWriterBinary() { this.Close(); }		#endregion		#region Methods		public string Read(string fileName)		{			// make sure that fileName is a file that ends in .metadata, so most likely an EarLab data file.			if (!fileName.EndsWith(".metadata"))				throw new System.Exception("ReaderWriterBinary: This constructor should only be used with an EarLab Metadata file");			// make sure the files we need exist on the system			if (!File.Exists(fileName))				return "EarLab Metadata file was not found.  Please verify file existence.";			if (!File.Exists(fileName.Replace(".metadata", ".binary")))				return "EarLab Data file was not found.  Please verify file existence.";			// read in and verify the metadata file, and return error string			string returnValue = this.ReadMetaDataFile(fileName);			if (returnValue != "0")				return returnValue;			// initialize the reader writer, and return error string			returnValue = this.Initialize(fileName.Replace(".metadata", ".binary"));			if (returnValue != "0")				return returnValue;			return "0";		}		private string ReadMetaDataFile(string fileName)		{			DataSet xmlDataSet;			try			{				xmlDataSet = ReaderWriterXMLMetadata.Read(fileName);			}			catch (Exception e)			{				return e.Message.ToString();			}						if (xmlDataSet != null)			{				// store the min/max values				this.minimumValue = (double)xmlDataSet.Tables["Parameters"].Rows[0]["MinimumValue"];				this.maximumValue = (double)xmlDataSet.Tables["Parameters"].Rows[0]["MaximumValue"];				this.unitsString = (string)xmlDataSet.Tables["Parameters"].Rows[0]["Units"];				// read in the dimensions, store them, and sort them so that they are ordered				this.dimensionsArray = new Dimension[xmlDataSet.Tables["Dimension"].Rows.Count];				int[] indexArray = new int[this.dimensionsArray.Length];				for (int i=0;i<this.dimensionsArray.Length;i++)				{					this.dimensionsArray[i].Name = (string)xmlDataSet.Tables["Dimension"].Rows[i]["Name"];					this.dimensionsArray[i].Size = (long)xmlDataSet.Tables["Dimension"].Rows[i]["Size"];					this.dimensionsArray[i].Index = int.Parse(xmlDataSet.Tables["Dimension"].Rows[i]["Index"].ToString());					DataRow axisRow = xmlDataSet.Tables["Dimension"].Rows[i].GetChildRows("Dimension_Axis")[0];					if (axisRow.GetChildRows("Axis_Auto").Length > 0)					{						DataRow autoRow = axisRow.GetChildRows("Axis_Auto")[0];						this.dimensionsArray[i].Start = (double)autoRow["StartValue"];						this.dimensionsArray[i].End = (double)autoRow["EndValue"];					}					else					{						DataRow[] arrayRows = axisRow.GetChildRows("Axis_Array")[0].GetChildRows("Array_Element");						int[] index2Array = new int[arrayRows.Length];						this.dimensionsArray[i].ElementArray = new double[arrayRows.Length];						for (int j=0; j<arrayRows.Length; j++)						{							index2Array[j] = (int)arrayRows[j]["Index"];							this.dimensionsArray[i].ElementArray[j] = (double)arrayRows[j]["Value"];						}						Array.Sort(index2Array, this.dimensionsArray[i].ElementArray);						this.dimensionsArray[i].Start = 0;						this.dimensionsArray[i].End = (double)(arrayRows.Length-1);					}					indexArray[i] = this.dimensionsArray[i].Index;				}				Array.Sort(indexArray, this.dimensionsArray);								// check to make sure that the dimensions in the metadata line up with binary file length				long fileLength;				try				{					fileLength = new FileInfo(fileName.Replace(".metadata", ".binary")).Length;				}				catch				{					return "EarLab Data file could not be opened or read successfully.";				}				long tempLength = 1;				foreach (Dimension dimension in this.dimensionsArray)					tempLength *= dimension.Size;				tempLength *= FLOAT_BYTES;				if (tempLength != fileLength)					return "Incorrect EarLab Metadata dimension values vs EarLab Data file length.";				return "0";			}			else				return "Incorrect EarLab Metadata file format.  Please verify file contents.";		}		private string Initialize(string fileName)		{			this.fileName = fileName;						if (this.outputFileReader != null)				this.outputFileReader.Close();			try			{				this.outputFileReader = new BinaryReader(new FileStream(this.fileName, FileMode.Open, FileAccess.Read, FileShare.Read));			}			catch			{				return "EarLab Data file could not be opened or read successfully.";			}			return "0";		}		public void GetData(ref double[,] dataArray, long offset)		{			// kick out some exceptions if user requests something silly			if (this.dimensionsArray.Length == 2 && (dataArray.GetLength(1) != this.dimensionsArray[0].Size))				throw new System.Exception("ReaderWriterBinary.GetData: Data array supplied does not match file dimension sizes.");			else if (this.dimensionsArray.Length == 3 && (dataArray.GetLength(0) < this.dimensionsArray[1].Size || dataArray.GetLength(1) != this.dimensionsArray[0].Size))				throw new System.Exception("ReaderWriterBinary.GetData: Data array supplied does not match file dimension sizes.");						// create some local variables for speed of calculation			int dataArrayLength0 = dataArray.GetLength(0);			int dataArrayLength1 = dataArray.GetLength(1);			double[] strideArray = new double[dataArrayLength1];			// figure out the offset into the file, based on number of dimensions			if (this.dimensionsArray.Length == 2)				offset *= dataArrayLength1*FLOAT_BYTES;			else				offset *= dataArrayLength0*dataArrayLength1*FLOAT_BYTES;			// read float values from the file, and if requesting more than the file size, return 0s			outputFileReader.BaseStream.Seek(offset, SeekOrigin.Begin);			for (int i=0; i<dataArrayLength0; i++)			{				if (outputFileReader.BaseStream.Position+dataArrayLength1*FLOAT_BYTES >= outputFileReader.BaseStream.Length)					for (int j=0; j<dataArrayLength1; j++)						dataArray[i,j] = 0;				else					for (int j=0; j<dataArrayLength1; j++)						dataArray[i,j] = outputFileReader.ReadSingle();			}		}		public void GetData(ref double[,] dataArray, long offset, int zoom)		{			// kick out some exceptions if user requests something silly			if (this.dimensionsArray.Length == 2 && (dataArray.GetLength(0) > this.dimensionsArray[1].Size || dataArray.GetLength(1) != this.dimensionsArray[0].Size))				throw new System.Exception("ReaderWriterBinary.GetData: Data array supplied does not match file dimension sizes.");			else if (this.dimensionsArray.Length == 3 && (dataArray.GetLength(0) < this.dimensionsArray[1].Size || dataArray.GetLength(1) != this.dimensionsArray[0].Size))				throw new System.Exception("ReaderWriterBinary.GetData: Data array supplied does not match file dimension sizes.");						// create some local variables for speed of calculation			int dataArrayLength0 = dataArray.GetLength(0);			int dataArrayLength1 = dataArray.GetLength(1);			double[] strideArray = new double[dataArrayLength1];			// figure out the offset into the file, based on number of dimensions			if (this.dimensionsArray.Length == 2)				offset *= dataArrayLength1*FLOAT_BYTES;			else				offset *= dataArrayLength0*dataArrayLength1*FLOAT_BYTES;			// read float values from the file, and if requesting more than the file size, return 0s			outputFileReader.BaseStream.Seek(offset, SeekOrigin.Begin);			for (int i=0; i<dataArrayLength0; i++)			{				if (this.outputFileReader.BaseStream.Position+dataArrayLength1*FLOAT_BYTES >= outputFileReader.BaseStream.Length)					for (int j=0; j<dataArrayLength1; j++)						dataArray[i,j] = 0;				else					for (int j=0; j<dataArrayLength1; j++)						dataArray[i,j] = outputFileReader.ReadSingle();				this.outputFileReader.BaseStream.Seek((zoom-1)*dataArrayLength1*FLOAT_BYTES, SeekOrigin.Current);			}		}		#endregion		#region Properties		public double Min		{			get { return this.minimumValue; }		}		public double Max		{			get { return this.maximumValue; }		}		public string Units		{			get { return this.unitsString; }		}		public Dimension[] Dimensions		{			get { return this.dimensionsArray; }		}		#endregion	}}