using System;using System.IO;using System.Windows.Forms;using System.Text;using System.Data;using System.Collections;namespace EarLab.ReaderWriters{	/// <summary>	/// This class can be used to read EarLab spike data from file.	/// </summary>	public class ReaderWriterBinarySpikes	{		public struct IndexItem		{			public double Time;			public int Count;		}		public class SpikeItem		{			public int cellID;			public double time;			public SpikeItem(int cellID, double time)			{				this.cellID = cellID;				this.time = time;			}		}		private	const int DOUBLE_BYTES = 8;		private const int INT_BYTES = 4;		private string fileName;		private BinaryReader outputFileReader;		private IndexItem[] indexesArray;		private double indexStep;		private string timeUnits;		private int cellCount;		private double timeMaximum;				private Hashtable indexesHash;		private SpikeItem[] internalArray;		#region Construtor/Destructor		public ReaderWriterBinarySpikes(){}		public void Close()		{			if (this.outputFileReader != null)			{				this.outputFileReader.Close();				this.outputFileReader = null;			}		}		~ReaderWriterBinarySpikes() { this.Close(); }		#endregion		#region Methods		public string Read(string fileName)		{			// make sure that fileName is a file that ends in .metadata, so most likely an EarLab data file.			if (!fileName.EndsWith(".index"))				throw new System.Exception("ReaderWriterBinarySpikes: This constructor should only be used with an EarLab Spikes file");			// make sure the files we need exist on the system			if (!File.Exists(fileName))				return "EarLab Spikes file was not found.  Please verify file existence.";			if (!File.Exists(fileName.Replace(".index", ".binary")))				return "EarLab Data file was not found.  Please verify file existence.";			// read in and verify the metadata file, and return error string			string returnValue = this.ReadMetaDataFile(fileName);			if (returnValue != "0")				return returnValue;			// initialize the reader writer, and return error string			returnValue = this.Initialize(fileName.Replace(".index", ".binary"));			if (returnValue != "0")				return returnValue;			return "0";		}		private string ReadMetaDataFile(string fileName)		{			DataSet xmlDataSet;			try			{				xmlDataSet = ReaderWriterXMLSpikes.Read(fileName);			}			catch (Exception e)			{				return e.Message.ToString();			}						if (xmlDataSet != null)			{				// read out the neccessary parameters				this.indexStep = (double)Math.Abs((double)xmlDataSet.Tables["Parameters"].Rows[0]["TimeStep"]);				this.timeUnits = (string)xmlDataSet.Tables["Parameters"].Rows[0]["TimeUnits"];				this.cellCount = int.Parse(xmlDataSet.Tables["Parameters"].Rows[0]["CellCount"].ToString());				// read in the spikes, and arrange them into a two column array				this.indexesArray = new IndexItem[xmlDataSet.Tables["Spike"].Rows.Count];				for (int i=0;i<this.indexesArray.Length;i++)				{					this.indexesArray[i].Time = (double)xmlDataSet.Tables["Spike"].Rows[i]["Time"];					this.indexesArray[i].Count = int.Parse(xmlDataSet.Tables["Spike"].Rows[i]["TotalCount"].ToString());				}				return "0";			}			else				return "Incorrect EarLab Spikes Index file format.  Please verify file contents.";		}		private string Initialize(string fileName)		{			this.fileName = fileName;						if (this.outputFileReader != null)				this.outputFileReader.Close();			try			{				this.outputFileReader = new BinaryReader(new FileStream(this.fileName, FileMode.Open, FileAccess.Read, FileShare.Read));			}			catch			{				return "EarLab Data file could not be opened or read successfully.";			}			this.indexesHash = new Hashtable();			foreach (IndexItem item in this.indexesArray)				this.indexesHash.Add(item.Time, item.Count);			this.outputFileReader.BaseStream.Seek(this.outputFileReader.BaseStream.Length-DOUBLE_BYTES, SeekOrigin.Begin);			this.timeMaximum = this.outputFileReader.ReadDouble();			this.ReadAll();			return "0";		}		public void GetData(double startTime, double endTime, out SpikeItem[] spikesArray)		{			double estStartTime = Math.Max(0, Math.Round(startTime-this.indexStep*0.5, 3));			double estEndTime = Math.Min(this.indexesArray[this.indexesArray.Length-1].Time, Math.Round(endTime+this.indexStep*0.5, 3));			int startCount = (int)this.indexesHash[estStartTime];			int endCount = (int)this.indexesHash[estEndTime];			spikesArray = new SpikeItem[endCount-startCount];			for (int i=0; i<spikesArray.Length; i++)				spikesArray[i] = this.internalArray[startCount+i];		}		private void ReadAll()		{			int spikeCount = (int)(this.outputFileReader.BaseStream.Length / (DOUBLE_BYTES+INT_BYTES));			this.outputFileReader.BaseStream.Seek(0, System.IO.SeekOrigin.Begin);			ArrayList tempArray = new ArrayList();			int cellID;			double time;			for (int i=0; i<spikeCount; i++)			{				cellID = this.outputFileReader.ReadInt32();				time = this.outputFileReader.ReadDouble();				tempArray.Add(new SpikeItem(cellID, time));			}			this.internalArray = new SpikeItem[tempArray.Count];			for (int i=0; i<this.internalArray.Length; i++)				this.internalArray[i] = (SpikeItem)tempArray[i];		}/*		public void GetData(double startTime, double endTime, out SpikeItem[] spikesArray)		{			ArrayList tempArray = new ArrayList();			double estimatedTime = Math.Max(0, Math.Round(startTime-this.indexStep*0.5, 3));			int spikeCount = (int)this.indexesHash[estimatedTime];			this.outputFileReader.BaseStream.Seek(spikeCount*(DOUBLE_BYTES+INT_BYTES), System.IO.SeekOrigin.Begin);					int cellID;			double time;			while (this.outputFileReader.BaseStream.Length >= this.outputFileReader.BaseStream.Position+DOUBLE_BYTES+INT_BYTES)			{				cellID = this.outputFileReader.ReadInt32();				time = this.outputFileReader.ReadDouble();				if (time >= endTime)					break;				else if (time >= startTime)					tempArray.Add(new SpikeItem(cellID, time));			}			spikesArray = new SpikeItem[tempArray.Count];			for (int i=0; i<spikesArray.Length; i++)				spikesArray[i] = (SpikeItem)tempArray[i];		}*/		#endregion		#region Properties		public string TimeUnits		{			get { return this.timeUnits; }		}		public IndexItem[] IndexArray		{			get { return this.indexesArray; }		}		public int CellCount		{			get { return this.cellCount; }		}		public double TimeMaximum		{			get { return this.timeMaximum; }		}		#endregion	}}