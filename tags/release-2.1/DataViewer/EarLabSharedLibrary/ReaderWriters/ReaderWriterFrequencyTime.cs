using System;using System.IO;using System.Windows.Forms;using System.Text;using System.Data;namespace EarLab.ReaderWriters{	/// <summary>	/// This class can be used to read EarLab muli-channel 2 dimensional data from file.	/// </summary>	public class ReaderWriterFrequencyTime	{		private	const int FLOAT_BYTES = 4;		private string fileName;		private long timeDimension, freqDimension;		private double maximumSample, minimumSample, sampleRate;		private BinaryReader outputFileReader;		/// <summary>		/// Create a new ReaderWriterFrequencyTime given a .metadata file.		/// </summary>		/// <param name="fileName">Name and path of the target file to be opened.</param>		public ReaderWriterFrequencyTime(string fileName)		{			// make sure that fileName is a file that ends in .metadata, so most likely an EarLab data file, and check that the file exists along with .binary data file			if (!fileName.EndsWith(".metadata"))				throw new System.Exception("MultiChannel2DReaderWriter.MultiChannel2DReaderWriter(fileName): This constructor should only be used with a .metadata EarLab data file");			if (!File.Exists(fileName))				throw new FileNotFoundException("MultiChannel2DReaderWriter.Initialize(fileName): EarLab .metadata parameter file was not found.", fileName);			if (!File.Exists(fileName.Replace(".metadata", ".binary")))				throw new FileNotFoundException("MultiChannel2DReaderWriter.Initialize(fileName): EarLab .binary data file was not found.", fileName.Replace(".metadata", ".binary"));			this.ReadMetaDataFile(fileName);			this.Initialize(fileName.Replace(".metadata", ".binary"));		}		/// <summary>		/// This method (destructor) finalizes this class		/// </summary>		~ReaderWriterFrequencyTime()		{			this.Close();		}		#region Methods		/// <summary>		/// Read in EarLab .metadata parameter file and store appropriate values to local variables		/// </summary>		private void ReadMetaDataFile(string fileName)		{			DataSet xmlDataSet = ReaderWriterXMLMetadata.Read(fileName);						if (xmlDataSet != null)			{				this.minimumSample = (double)xmlDataSet.Tables["Parameters"].Rows[0]["MinValue"];				this.maximumSample = (double)xmlDataSet.Tables["Parameters"].Rows[0]["MaxValue"];				this.sampleRate = (double)xmlDataSet.Tables["Parameters"].Rows[0]["SampleRate_Hz"];				this.timeDimension = (long)xmlDataSet.Tables["Dimension"].Select("Name = 'Time'")[0]["Value"];				this.freqDimension = (long)xmlDataSet.Tables["Dimension"].Select("Name = 'Frequency'")[0]["Value"];				long fileLength;				try				{					fileLength = new FileInfo(fileName.Replace(".metadata", ".binary")).Length;				}				catch				{					throw new Exception("ReaderWriterFrequencyTime.ReadMetaDataFile(): EarLab Data (.binary) file not found.");				}				if (this.timeDimension*this.freqDimension*FLOAT_BYTES != fileLength)					throw new Exception("ReaderWriterFrequencyTime.ReadMetaDataFile(): Incorrect EarLab Metadata (.metadata) file vs Data (.binary) file.");			}			else			{				throw new Exception("XMLMetadataReaderWriter.Read(fileName): Incorrect EarLab .metadata file format.");			}		}		/// <summary>		/// Initialize the MultiChannel2DReaderWriter to read a file.		/// </summary>		/// <param name="fileName">The name and path of the target file to read.</param>		private void Initialize(string fileName)		{			this.fileName = fileName;						if (this.outputFileReader != null)				this.outputFileReader.Close();			try			{				this.outputFileReader = new BinaryReader(new FileStream(this.fileName, FileMode.Open, FileAccess.Read, FileShare.Read));			}			catch			{				throw new Exception("ReaderWriterFrequencyTime.Initialize(fileName): Unable to open .binary file.");			}		}		/// <summary>		/// Read data from file and write it to supplied array.		/// </summary>		/// <param name="timeStart">Time dimension sample position in file to start read.</param>		/// <param name="timeEnd">Time dimension sample position in file to stop read.</param>		/// <param name="arrayIndex">Index in supplied array to write data read from file.</param>		/// <param name="dataArray">Array into which data read from file is stored.</param>		public void GetData(long timeStart, long timeEnd, long arrayIndex, ref double[,] dataArray)		{			// check to make sure entered values are correct and data array supplied if of correct size			if (timeStart < 0 || timeEnd < 1)				throw new System.Exception("ReaderWriterFrequencyTime.GetData: Time sample start must be greater than or equal to zero, and time sample end must be greater than zero");			if (timeStart >= timeEnd)				throw new System.Exception("ReaderWriterFrequencyTime.GetData: Time start sample must be less than time end sample.");			if (arrayIndex < 0 || arrayIndex+(timeEnd-timeStart)-1 >= dataArray.GetLength(0))				throw new System.Exception("ReaderWriterFrequencyTime.GetData: Attempting to index outside dataArray bounds.");			if (dataArray.GetLength(1) != this.freqDimension)				throw new System.Exception("ReaderWriterFrequencyTime.GetData: Data array frequency dimension size is incorrect.");			// fill supplied data array with values from file, beginning at the specified index for specified number of samples			int timeSamples = (int)(timeEnd - timeStart);			double[] strideArray = new double[this.freqDimension];			for (int i=0; i<timeSamples; i++)			{				// read a stride (all freq values) from the file, and add to supplied data array				this.ReadStrideFromFile(timeStart+i, ref strideArray);				for (int j=0; j<this.freqDimension; j++)					dataArray[i+arrayIndex, j] = strideArray[j];			}		}		/// <summary>		/// Read a stride (frequency dimension) amount of data from file and write to supplied array.		/// </summary>		/// <param name="timeStart">Time dimension sample position in file to start read.</param>		/// <param name="strideArray">Array into which data read from the file is stored.</param>		private void ReadStrideFromFile(long timeStart, ref double[] strideArray)		{			// calculate offset into file based on starting time sample position			long streamOffSet = (long)(timeStart*freqDimension*FLOAT_BYTES);			// check to make sure that we are not trying to read outside file, if so fill strideArray with minimum values			if (streamOffSet+freqDimension*FLOAT_BYTES >= outputFileReader.BaseStream.Length)			{				for (int i=0; i<strideArray.Length; i++)					strideArray[i] = 0;				return;			}			// seek to neccessary position in file and read out a stride of data			outputFileReader.BaseStream.Seek(streamOffSet, SeekOrigin.Begin);			for (int i=0; i<freqDimension; i++)				strideArray[i] = outputFileReader.ReadSingle();		}		/// <summary>		/// Closes all open files or socket connections		/// </summary>		public void Close()		{			if (this.outputFileReader != null)			{				this.outputFileReader.Close();				this.outputFileReader = null;			}		}		#endregion		#region Properties		/// <summary>		/// Get Time dimension size of file.		/// </summary>		public long Time		{			get			{				if (this.outputFileReader == null)					throw new System.Exception("ReaderWriterFrequencyTime.Time: No valid data to return in current state.");				return this.timeDimension;			}		}		/// <summary>		/// Get Frequency dimension size of file.		/// </summary>		public long Frequency		{			get			{				if (this.outputFileReader == null)					throw new System.Exception("ReaderWriterFrequencyTime.Frequency: No valid data to return in current state.");				return this.freqDimension;			}		}		/// <summary>		/// Get the sample rate of the file or socket data.		/// </summary>		public double SampleRate		{			get			{				if (this.outputFileReader == null)					throw new System.Exception("ReaderWriterFrequencyTime.SampleRate: No valid data to return in current state.");				return this.sampleRate;			}		}		/// <summary>		/// Get the minimum data value from the file or socket data.		/// </summary>		public double Min		{			get			{				if (this.outputFileReader == null)					throw new System.Exception("ReaderWriterFrequencyTime.Min: No valid data to return in current state.");				return this.minimumSample;			}		}		/// <summary>		/// Get the maximum data value from the file or socket data.		/// </summary>		public double Max		{			get			{				if (this.outputFileReader == null)					throw new System.Exception("ReaderWriterFrequencyTime.Max: No valid data to return in current state.");				return this.maximumSample;			}		}		#endregion	}}